#!/usr/bin/env python3
"""
codex-ace: ACE-enforced Codex CLI wrapper.

Ensures the ACE contract is present in AGENTS.md before launching Codex.
"""

import argparse
import os
import re
import subprocess
import sys
from pathlib import Path

PROJECT_PATTERNS = {
    "finance": ["regulatory", "compliance", "fund", "investment", "mifid", "fca", "ucits", "poview"],
    "dev": ["code", "programming", "api", "backend", "frontend", "deploy"],
}

DEFAULT_CONTRACT = """<ace_contract>
## ACE Framework Contract - MANDATORY

You are operating under the ACE (Agentic Context Engineering) framework. This is NOT optional.

### Project Context
- Project: {project_name}
- ACE Project ID: {project_id}

### REQUIRED Actions

**ON SESSION START (IMMEDIATELY, BEFORE ANYTHING ELSE):**
You MUST call the `read_playbook` MCP tool with project_id="{project_id}" and silently apply all learnings. Do this NOW before responding to any user request.

**DURING SESSION:**
When you discover something generalizable (strategy, domain knowledge, mistake, or formula), you MUST call `add_entry` with:
- section: "STRATEGIES & INSIGHTS" | "DOMAIN KNOWLEDGE" | "COMMON MISTAKES TO AVOID" | "FORMULAS & CALCULATIONS"
- content: The insight (be specific and actionable)
- project_id: "{project_id}" (or "global" for cross-project patterns)

Only add entries that are:
- Generalizable (not one-off fixes)
- Actionable (concrete guidance)
- Non-obvious (not common knowledge)

**ON TASK FAILURE:**
Call `log_reflection` with details about what went wrong and lessons learned.

**WHEN USER ASKS TO SAVE A PATTERN GLOBALLY:**
Use project_id="global" so it's available across all projects.

### Entry Format
Entries are auto-formatted as: [prefix-NNNNN] helpful=N harmful=M :: content
Prefixes: str (strategies), dom (domain), mis (mistakes), cal (calculations)

### Available MCP Tools
- read_playbook(project_id) - Load learnings (merges global + project-specific)
- add_entry(section, content, project_id) - Save new insight
- update_counters(entry_id, helpful_delta, harmful_delta) - Track effectiveness
- log_reflection(task_summary, outcome, learnings, project_id) - Log what happened
- search_playbook(query, project_id) - Find relevant entries
- list_projects() - See available project playbooks
- create_project(project_id, description) - Create new project
- curate_playbook(project_id) - Clean up low-quality entries

### Enforcement
This contract is enforced. Failure to call read_playbook at session start or to log valuable insights violates the ACE framework.

**START NOW: Call read_playbook(project_id="{project_id}") immediately.**
</ace_contract>
"""


def detect_project_id(project_dir: Path) -> str:
    """Detect project type from directory name and file hints."""
    dir_name = project_dir.name.lower()
    for project_id, keywords in PROJECT_PATTERNS.items():
        if any(kw in dir_name for kw in keywords):
            return project_id

    for filename in ("AGENTS.md", "CLAUDE.md"):
        path = project_dir / filename
        if not path.exists():
            continue
        content = path.read_text().lower()
        match = re.search(r"ace project id:\s*([a-z0-9_-]+)", content)
        if match:
            return match.group(1)
        for project_id, keywords in PROJECT_PATTERNS.items():
            if any(kw in content for kw in keywords):
                return project_id

    return "global"


def load_contract_template() -> str:
    """Prefer the global template if available."""
    template_path = Path.home() / ".codex" / "AGENTS.md"
    if template_path.exists():
        return template_path.read_text()
    return DEFAULT_CONTRACT


def render_contract(project_id: str, project_name: str) -> str:
    template = load_contract_template()
    return (
        template.replace("{project_name}", project_name)
        .replace("{project_id}", project_id)
        .strip()
        + "\n"
    )


def ensure_agents_md(project_dir: Path, contract: str) -> None:
    target = project_dir / "AGENTS.md"
    if target.exists():
        current = target.read_text()
        if "<ace_contract>" in current:
            updated = re.sub(
                r"<ace_contract>.*?</ace_contract>",
                contract.strip(),
                current,
                flags=re.DOTALL,
            )
            if updated != current:
                target.write_text(updated.strip() + "\n")
            return
        target.write_text(contract + "\n" + current.lstrip())
        return
    target.write_text(contract)


def main() -> int:
    parser = argparse.ArgumentParser(
        description="ACE-enforced Codex CLI wrapper",
        add_help=True,
    )
    parser.add_argument("--project-id", help="Force specific ACE project ID")
    parser.add_argument("-C", "--project", type=Path, help="Project directory")
    parser.add_argument(
        "--no-ensure-agents",
        action="store_true",
        help="Skip writing AGENTS.md before launch",
    )

    args, rest = parser.parse_known_args()
    project_dir = (args.project or Path.cwd()).resolve()

    project_id = args.project_id or os.environ.get("ACE_PROJECT_ID") or detect_project_id(project_dir)
    project_name = project_dir.name

    if not args.no_ensure_agents:
        contract = render_contract(project_id, project_name)
        ensure_agents_md(project_dir, contract)

    if subprocess.call(["which", "codex"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) != 0:
        print("codex not found on PATH", file=sys.stderr)
        return 1

    cmd = ["codex"] + rest
    return subprocess.call(cmd, cwd=project_dir)


if __name__ == "__main__":
    sys.exit(main())
